"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalDocumentIndex = void 0;
const fs = __importStar(require("fs/promises"));
const path = __importStar(require("path"));
const uuid_1 = require("uuid");
const GPT3Tokenizer_1 = require("./GPT3Tokenizer");
const LocalIndex_1 = require("./LocalIndex");
const TextSplitter_1 = require("./TextSplitter");
const LocalDocumentResult_1 = require("./LocalDocumentResult");
const LocalDocument_1 = require("./LocalDocument");
class LocalDocumentIndex extends LocalIndex_1.LocalIndex {
    constructor(config) {
        var _a, _b;
        super(config.folderPath);
        this._embeddings = config.embeddings;
        this._chunkingConfig = Object.assign({
            keepSeparators: true,
            chunkSize: 512,
            chunkOverlap: 0,
        }, config.chunkingConfig);
        this._tokenizer = (_b = (_a = config.tokenizer) !== null && _a !== void 0 ? _a : this._chunkingConfig.tokenizer) !== null && _b !== void 0 ? _b : new GPT3Tokenizer_1.GPT3Tokenizer();
        this._chunkingConfig.tokenizer = this._tokenizer;
    }
    /**
     * Returns true if the document catalog exists.
     */
    isCatalogCreated() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield fs.access(path.join(this.folderPath, 'catalog.json'));
                return true;
            }
            catch (err) {
                return false;
            }
        });
    }
    getDocumentId(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadIndexData();
            return (_a = this._catalog) === null || _a === void 0 ? void 0 : _a.uriToId[uri];
        });
    }
    getDocumentUri(documentId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadIndexData();
            return (_a = this._catalog) === null || _a === void 0 ? void 0 : _a.idToUri[documentId];
        });
    }
    createIndex(config) {
        const _super = Object.create(null, {
            createIndex: { get: () => super.createIndex }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.createIndex.call(this, config);
            yield this.loadIndexData();
        });
    }
    deleteDocument(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            // Lookup document ID
            const documentId = yield this.getDocumentId(uri);
            if (documentId == undefined) {
                return;
            }
            // Delete document chunks from index and remove from catalog
            yield this.beginUpdate();
            try {
                // Get list of chunks for document
                const chunks = yield this.listItemsByMetadata({ documentId });
                // Delete chunks
                for (const chunk of chunks) {
                    yield this.deleteItem(chunk.id);
                }
                // Remove entry from catalog
                delete this._newCatalog.uriToId[uri];
                delete this._newCatalog.idToUri[documentId];
                this._newCatalog.count--;
                // Commit changes
                yield this.endUpdate();
            }
            catch (err) {
                // Cancel update and raise error
                this.cancelUpdate();
                throw new Error(`Error deleting document "${uri}": ${err.toString()}`);
            }
            // Delete text file from disk
            try {
                yield fs.unlink(path.join(this.folderPath, `${documentId}.txt`));
            }
            catch (err) {
                throw new Error(`Error removing text file for document "${uri}" from disk: ${err.toString()}`);
            }
            // Delete metadata file from disk
            try {
                yield fs.unlink(path.join(this.folderPath, `${documentId}.json`));
            }
            catch (err) {
                // Ignore error
            }
        });
    }
    getCatalogStats() {
        return __awaiter(this, void 0, void 0, function* () {
            const stats = yield this.getIndexStats();
            return {
                version: this._catalog.version,
                documents: this._catalog.count,
                chunks: stats.items,
                metadata_config: stats.metadata_config
            };
        });
    }
    /**
     * Adds a document to the catalog.
     * @remarks
     * A new update is started if one is not already in progress. If an document with the same uri
     * already exists, it will be replaced.
     * @param uri - Document URI
     * @param text - Document text
     * @param docType - Optional. Document type
     * @param metadata - Optional. Document metadata to index
     * @returns Inserted document
     */
    upsertDocument(uri, text, docType, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure embeddings configured
            if (!this._embeddings) {
                throw new Error(`Embeddings model not configured.`);
            }
            // Check for existing document ID
            let documentId = yield this.getDocumentId(uri);
            if (documentId != undefined) {
                // Delete existing document
                yield this.deleteDocument(uri);
            }
            else {
                // Generate new document ID
                documentId = (0, uuid_1.v4)();
            }
            // Initialize text splitter settings
            const config = Object.assign({ docType }, this._chunkingConfig);
            if (config.docType == undefined) {
                // Populate docType based on extension
                const pos = uri.lastIndexOf('.');
                if (pos >= 0) {
                    const ext = uri.substring(pos + 1).toLowerCase();
                    config.docType = ext;
                }
            }
            // Split text into chunks
            const splitter = new TextSplitter_1.TextSplitter(config);
            const chunks = splitter.split(text);
            // Break chunks into batches for embedding generation
            let totalTokens = 0;
            const chunkBatches = [];
            let currentBatch = [];
            for (const chunk of chunks) {
                totalTokens += chunk.tokens.length;
                if (totalTokens > this._embeddings.maxTokens) {
                    chunkBatches.push(currentBatch);
                    currentBatch = [];
                    totalTokens = chunk.tokens.length;
                }
                currentBatch.push(chunk.text.replace(/\n/g, ' '));
            }
            if (currentBatch.length > 0) {
                chunkBatches.push(currentBatch);
            }
            // Generate embeddings for chunks
            const embeddings = [];
            for (const batch of chunkBatches) {
                let response;
                try {
                    response = yield this._embeddings.createEmbeddings(batch);
                }
                catch (err) {
                    throw new Error(`Error generating embeddings: ${err.toString()}`);
                }
                // Check for error
                if (response.status != 'success') {
                    throw new Error(`Error generating embeddings: ${response.message}`);
                }
                // Add embeddings to output
                for (const embedding of response.output) {
                    embeddings.push(embedding);
                }
            }
            // Add document chunks to index
            yield this.beginUpdate();
            try {
                // Add chunks to index
                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    const embedding = embeddings[i];
                    const chunkMetadata = Object.assign({
                        documentId,
                        startPos: chunk.startPos,
                        endPos: chunk.endPos,
                    }, metadata);
                    yield this.insertItem({
                        id: (0, uuid_1.v4)(),
                        metadata: chunkMetadata,
                        vector: embedding,
                    });
                }
                // Save metadata file to disk
                if (metadata != undefined) {
                    yield fs.writeFile(path.join(this.folderPath, `${documentId}.json`), JSON.stringify(metadata));
                }
                // Save text file to disk
                yield fs.writeFile(path.join(this.folderPath, `${documentId}.txt`), text);
                // Add entry to catalog
                this._newCatalog.uriToId[uri] = documentId;
                this._newCatalog.idToUri[documentId] = uri;
                this._newCatalog.count++;
                // Commit changes
                yield this.endUpdate();
            }
            catch (err) {
                // Cancel update and raise error
                this.cancelUpdate();
                throw new Error(`Error adding document "${uri}": ${err.toString()}`);
            }
            // Return document
            return new LocalDocument_1.LocalDocument(this.folderPath, documentId, uri);
        });
    }
    queryDocuments(query, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure embeddings configured
            if (!this._embeddings) {
                throw new Error(`Embeddings model not configured.`);
            }
            // Ensure options are defined
            options = Object.assign({
                maxDocuments: 10,
                maxChunks: 50,
            }, options);
            // Generate embeddings for query
            let embeddings;
            try {
                embeddings = yield this._embeddings.createEmbeddings(query.replace(/\n/g, ' '));
            }
            catch (err) {
                throw new Error(`Error generating embeddings for query: ${err.toString()}`);
            }
            // Check for error
            if (embeddings.status != 'success') {
                throw new Error(`Error generating embeddings for query: ${embeddings.message}`);
            }
            // Query index for chunks
            const results = yield this.queryItems(embeddings.output[0], options.maxChunks, options.filter);
            // Group chunks by document
            const documentChunks = {};
            for (const result of results) {
                const metadata = result.item.metadata;
                if (documentChunks[metadata.documentId] == undefined) {
                    documentChunks[metadata.documentId] = [];
                }
                documentChunks[metadata.documentId].push(result);
            }
            // Create a document result for each document
            const documentResults = [];
            for (const documentId in documentChunks) {
                const chunks = documentChunks[documentId];
                const uri = yield this.getDocumentUri(documentId);
                const documentResult = new LocalDocumentResult_1.LocalDocumentResult(this.folderPath, documentId, uri, chunks, this._tokenizer);
                documentResults.push(documentResult);
            }
            // Sort document results by score and return top results
            return documentResults.sort((a, b) => b.score - a.score).slice(0, options.maxDocuments);
        });
    }
    // Overrides
    beginUpdate() {
        const _super = Object.create(null, {
            beginUpdate: { get: () => super.beginUpdate }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.beginUpdate.call(this);
            this._newCatalog = Object.assign({}, this._catalog);
        });
    }
    cancelUpdate() {
        super.cancelUpdate();
        this._newCatalog = undefined;
    }
    endUpdate() {
        const _super = Object.create(null, {
            endUpdate: { get: () => super.endUpdate }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.endUpdate.call(this);
            try {
                // Save catalog
                yield fs.writeFile(path.join(this.folderPath, 'catalog.json'), JSON.stringify(this._newCatalog));
                this._catalog = this._newCatalog;
                this._newCatalog = undefined;
            }
            catch (err) {
                throw new Error(`Error saving document catalog: ${err.toString()}`);
            }
        });
    }
    loadIndexData() {
        const _super = Object.create(null, {
            loadIndexData: { get: () => super.loadIndexData }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.loadIndexData.call(this);
            if (this._catalog) {
                return;
            }
            const catalogPath = path.join(this.folderPath, 'catalog.json');
            if (yield this.isCatalogCreated()) {
                // Load catalog
                const buffer = yield fs.readFile(catalogPath);
                this._catalog = JSON.parse(buffer.toString());
            }
            else {
                try {
                    // Initialize catalog
                    this._catalog = {
                        version: 1,
                        count: 0,
                        uriToId: {},
                        idToUri: {},
                    };
                    yield fs.writeFile(catalogPath, JSON.stringify(this._catalog));
                }
                catch (err) {
                    throw new Error(`Error creating document catalog: ${err.toString()}`);
                }
            }
        });
    }
}
exports.LocalDocumentIndex = LocalDocumentIndex;
//# sourceMappingURL=LocalDocumentIndex.js.map