"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const fs = __importStar(require("fs/promises"));
const yargs_1 = __importDefault(require("yargs/yargs"));
const helpers_1 = require("yargs/helpers");
const LocalDocumentIndex_1 = require("./LocalDocumentIndex");
const WebFetcher_1 = require("./WebFetcher");
const OpenAIEmbeddings_1 = require("./OpenAIEmbeddings");
const internals_1 = require("./internals");
const FileFetcher_1 = require("./FileFetcher");
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        // prettier-ignore
        const args = yield (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
            .scriptName('vectra')
            .command('create <index>', `create a new local index`, {}, (args) => __awaiter(this, void 0, void 0, function* () {
            const folderPath = args.index;
            const index = new LocalDocumentIndex_1.LocalDocumentIndex({ folderPath });
            console.log(internals_1.Colorize.output(`creating index at ${folderPath}`));
            yield index.createIndex({ version: 1, deleteIfExists: true });
        }))
            .command('delete <index>', `delete an existing local index`, {}, (args) => __awaiter(this, void 0, void 0, function* () {
            const folderPath = args.index;
            console.log(internals_1.Colorize.output(`deleting index at ${folderPath}`));
            const index = new LocalDocumentIndex_1.LocalDocumentIndex({ folderPath });
            yield index.deleteIndex();
        }))
            .command('add <index>', `adds one or more web pages to an index`, (yargs) => {
            return yargs
                .option('keys', {
                alias: 'k',
                describe: 'path of a JSON file containing the model keys to use for generating embeddings',
                type: 'string'
            })
                .option('uri', {
                alias: 'u',
                array: true,
                describe: 'http/https link to a web page to add',
                type: 'string'
            })
                .option('list', {
                alias: 'l',
                describe: 'path to a file containing a list of web pages to add',
                type: 'string'
            })
                .option('cookie', {
                alias: 'c',
                describe: 'optional cookies to add to web fetch requests',
                type: 'string'
            })
                .option('chunk-size', {
                alias: 'cs',
                describe: 'size of the generated chunks in tokens (defaults to 512)',
                type: 'number',
                default: 512
            })
                .check((argv) => {
                if (Array.isArray(argv.uri) && argv.uri.length > 0) {
                    return true;
                }
                else if (typeof argv.list == 'string' && argv.list.trim().length > 0) {
                    return true;
                }
                else {
                    throw new Error(`you must specify either one or more "--uri <link>" for the pages to add or a "--list <file path>" for a file containing the list of pages to add.`);
                }
            })
                .demandOption(['keys']);
        }, (args) => __awaiter(this, void 0, void 0, function* () {
            console.log(internals_1.Colorize.title('Adding Web Pages to Index'));
            // Create embeddings
            const keys = JSON.parse(yield fs.readFile(args.keys, 'utf-8'));
            const embeddings = new OpenAIEmbeddings_1.OpenAIEmbeddings(Object.assign({ model: 'text-embedding-ada-002' }, keys));
            // Initialize index
            const folderPath = args.index;
            const index = new LocalDocumentIndex_1.LocalDocumentIndex({
                folderPath,
                embeddings,
                chunkingConfig: {
                    chunkSize: args.chunkSize
                }
            });
            // Get list of url's
            const uris = yield getItemList(args.uri, args.list, 'web page');
            // Fetch documents
            const fileFetcher = new FileFetcher_1.FileFetcher();
            const webFetcher = args.cookie ? new WebFetcher_1.WebFetcher({ headers: { "cookie": args.cookie } }) : new WebFetcher_1.WebFetcher();
            for (const path of uris) {
                try {
                    console.log(internals_1.Colorize.progress(`fetching ${path}`));
                    const fetcher = path.startsWith('http') ? webFetcher : fileFetcher;
                    yield fetcher.fetch(path, (uri, text, docType) => __awaiter(this, void 0, void 0, function* () {
                        console.log(internals_1.Colorize.replaceLine(internals_1.Colorize.progress(`indexing ${uri}`)));
                        yield index.upsertDocument(uri, text, docType);
                        console.log(internals_1.Colorize.replaceLine(internals_1.Colorize.success(`added ${uri}`)));
                        return true;
                    }));
                }
                catch (err) {
                    console.log(internals_1.Colorize.replaceLine(internals_1.Colorize.error(`Error adding: ${path}\n${err.message}`)));
                }
            }
        }))
            .command('remove <index>', `removes one or more documents from an index`, (yargs) => {
            return yargs
                .option('uri', {
                alias: 'u',
                array: true,
                describe: 'uri of a document to remove',
                type: 'string'
            })
                .option('list', {
                alias: 'l',
                describe: 'path to a file containing a list of documents to remove',
                type: 'string'
            })
                .check((argv) => {
                if (Array.isArray(argv.uri) && argv.uri.length > 0) {
                    return true;
                }
                else if (typeof argv.list == 'string' && argv.list.trim().length > 0) {
                    return true;
                }
                else {
                    throw new Error(`you must specify either one or more "--uri <link>" for the pages to add or a "--list <file path>" for a file containing the list of pages to add.`);
                }
            });
        }, (args) => __awaiter(this, void 0, void 0, function* () {
            // Initialize index
            const folderPath = args.index;
            const index = new LocalDocumentIndex_1.LocalDocumentIndex({ folderPath });
            // Get list of uri's
            const uris = yield getItemList(args.uri, args.list, 'document');
            // Remove documents
            for (const uri of uris) {
                console.log(`removing ${uri}`);
                yield index.deleteDocument(uri);
            }
        }))
            .command('stats <index>', `prints the stats for a local index`, {}, (args) => __awaiter(this, void 0, void 0, function* () {
            const folderPath = args.index;
            const index = new LocalDocumentIndex_1.LocalDocumentIndex({ folderPath });
            const stats = yield index.getCatalogStats();
            console.log(internals_1.Colorize.title('Index Stats'));
            console.log(internals_1.Colorize.output(stats));
        }))
            .command('query <index> <query>', `queries a local index`, (yargs) => {
            return yargs
                .option('keys', {
                alias: 'k',
                describe: 'path of a JSON file containing the model keys to use for generating embeddings'
            })
                .option('document-count', {
                alias: 'dc',
                describe: 'max number of documents to return (defaults to 10)',
                type: 'number',
                default: 10
            })
                .option('chunk-count', {
                alias: 'cc',
                describe: 'max number of chunks to return (defaults to 50)',
                type: 'number',
                default: 50
            })
                .option('section-count', {
                alias: 'sc',
                describe: 'max number of document sections to render (defaults to 1)',
                type: 'number',
                default: 1
            })
                .option('tokens', {
                alias: 't',
                describe: 'max number of tokens to render for each document section (defaults to 2000)',
                type: 'number',
                default: 2000
            })
                .option('format', {
                alias: 'f',
                describe: `format of the rendered results. Defaults to 'sections'`,
                choices: ['sections', 'stats', 'chunks'],
                default: 'sections'
            })
                .option('overlap', {
                alias: 'o',
                describe: `whether to add overlapping chunks to sections.`,
                type: 'boolean',
                default: true
            })
                .demandOption(['keys']);
        }, (args) => __awaiter(this, void 0, void 0, function* () {
            console.log(internals_1.Colorize.title('Querying Index'));
            // Create embeddings
            const keys = JSON.parse(yield fs.readFile(args.keys, 'utf-8'));
            const embeddings = new OpenAIEmbeddings_1.OpenAIEmbeddings(Object.assign({ model: 'text-embedding-ada-002' }, keys));
            // Initialize index
            const folderPath = args.index;
            const index = new LocalDocumentIndex_1.LocalDocumentIndex({
                folderPath,
                embeddings
            });
            // Query index
            const query = args.query;
            const results = yield index.queryDocuments(query, {
                maxDocuments: args.documentCount,
                maxChunks: args.chunkCount,
            });
            // Render results
            for (const result of results) {
                console.log(internals_1.Colorize.output(result.uri));
                console.log(internals_1.Colorize.value('score', result.score));
                console.log(internals_1.Colorize.value('chunks', result.chunks.length));
                if (args.format == 'sections') {
                    const sections = yield result.renderSections(args.tokens, args.sectionCount, args.overlap);
                    for (let i = 0; i < sections.length; i++) {
                        const section = sections[i];
                        console.log(internals_1.Colorize.title(args.sectionCount == 1 ? 'Section' : `Section ${i + 1}`));
                        console.log(internals_1.Colorize.value('score', section.score));
                        console.log(internals_1.Colorize.value('tokens', section.tokenCount));
                        console.log(internals_1.Colorize.output(section.text));
                    }
                }
                else if (args.format == 'chunks') {
                    const text = yield result.loadText();
                    for (let i = 0; i < result.chunks.length; i++) {
                        const chunk = result.chunks[i];
                        const startPos = chunk.item.metadata.startPos;
                        const endPos = chunk.item.metadata.endPos;
                        console.log(internals_1.Colorize.title(`Chunk ${i + 1}`));
                        console.log(internals_1.Colorize.value('score', chunk.score));
                        console.log(internals_1.Colorize.value('startPos', startPos));
                        console.log(internals_1.Colorize.value('endPos', endPos));
                        console.log(internals_1.Colorize.output(text.substring(startPos, endPos + 1)));
                    }
                }
            }
        }))
            .help()
            .demandCommand()
            .parseAsync();
    });
}
exports.run = run;
function getItemList(items, listFile, uriType) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(items) && items.length > 0) {
            return items;
        }
        else if (typeof listFile == 'string' && listFile.trim().length > 0) {
            const list = yield fs.readFile(listFile, 'utf-8');
            return list.split('\n').map((item) => item.trim()).filter((item) => item.length > 0);
        }
        else {
            throw new Error(`you must specify either one or more "--uri <${uriType}>" for the items or a "--list <file path>" for a file containing the items.`);
        }
    });
}
//# sourceMappingURL=vectra-cli.js.map